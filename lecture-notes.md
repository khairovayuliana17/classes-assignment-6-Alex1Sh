# НАСЛЕДОВАНИЕ
Недавно я посмотрела сериал "Дневники вампира", где вампиры, оборотни, гибриды и другие сверхъестественные существа обладают сложной иерархией сил и слабостей, которую, как я подумала, можно сравнить с наследованием в C++.
Представь, что ты разрабатываешь иерархию их необычного мира. Тебе нужно создать кучу персонажей, у всех них есть некие общие черты. Но писать для каждого из них одни и те же свойства снова и снова вообще неэффективно!

_**Наследование** - это возможность описания нового класса на основе уже существующего с заимствованием данных и функционала. Новый класс (наследник) получает все поля и методы родителя._

При наследовании **приватные поля** базового класса **недоступны в наследнике**.

`protected` - модификатор доступа, недоступный вне класса, как и `private`, но при наследовании он переходит как `protected` и доступен в наследнике.

### Базовый класс
В их сверхъестественном мире все начинается с обычного человека.
```cpp
class Human {
protected: // поля доступны в Human и его наследниках (Vampire, Werewolf...)
    std::string name;
    int age;
    bool isAlive;

public:
    Human(const std::string& name, int age)
        : name(name), age(age), isAlive(true) {}

    void becomeSupernatural() {
        // Может превратиться в вампира, оборотня и т. д.
    }

    ... // другие методы, геттеры и т.д.
};
```

_**Базовый класс** (родительский, или предок) — это что-то типа шаблона с общими характеристиками для других классов._

### Производный класс

Синтаксис:
`class Имя: public имя_базового_класса {};`

Производный класс Вампир (`Vampire`) наследует свойства человека, но добавляет новые способности и слабости.
```cpp
class Vampire : public Human {
private:
    int bloodLustLevel;
    bool daylightRing;  // Кольцо, защищающее от солнца

public:
    Vampire(const std::string& name, int age, bool hasDaylightRing = false)
        : Human(name, age), bloodLustLevel(100), daylightRing(hasDaylightRing) {}

    void drinkBlood() {
        bloodLustLevel -= 10;
        std::cout << name << " пьёт кровь. Уровень жажды: " << bloodLustLevel << std::endl;
    }

    void dieFromSunlight() {
        if (!daylightRing) {
            isAlive = false;
            std::cout << name << " сгорел на солнце!" << std::endl;
        }
    }

    void compel(const Human& human) {
        std::cout << name << " использует контроль разума на " << human.getName() << std::endl;
    }
};
```
#### Что Vampire унаследовал от Human?
Класс `Vampire` наследует все `protected` и `public` поля и методы `Human`. В нашем случае:

Поля (объявлены как `protected` в `Human`):

- `std::string name` — имя вампира (было у человека).
- `int age` — возраст (но теперь это возраст в "вампирских годах").
- `bool isAlive` — жив ли (у вампиров тоже есть состояние жизни/смерти).

Методы (`public` в `Human`):

- `becomeSupernatural()` — метод превращения (но вампир уже сверхъестественный, так что его можно  переопределить или не использовать).

#### Что Vampire добавил своего?
Новые поля (`private`):

- `int bloodLustLevel` — уровень жажды крови (100 по умолчанию).

- `bool daylightRing` — есть ли кольцо, защищающее от солнца.

Новые методы (`public`):

- `drinkBlood()` — уменьшает `bloodLustLevel` и выводит сообщение.

- `dieFromSunlight()` — проверяет, есть ли кольцо, и убивает вампира, если его нет.

- `compel()` — контроль разума (уникальная способность вампиров).


_**Производный класс (наследник)** - класс, наследуемый от базового._

#### Производный класс: Оборотень (Werewolf)
Оборотень тоже наследуется от человека, но с дополнительными особенностями.
```cpp
class Werewolf : public Human {
private:
    bool isTransformed;
    int angerLevel;

public:
    Werewolf(const std::string& name, int age)
        : Human(name, age), isTransformed(false), angerLevel(0) {}

    void transform() {
        if (angerLevel >= 50) {
            isTransformed = true;
            std::cout << name << " превращается в оборотня!" << std::endl;
        }
    }

    void calmDown() {
        angerLevel = 0;
        isTransformed = false;
    }

    void biteVampire(Vampire& vamp) {
        if (isTransformed) {
            std::cout << name << " кусает вампира " << vamp.getName() << "!" << std::endl;
            // Теперь вампир может стать гибридом...
        }
    }
};
```
#### Что Werewolf добавил своего?
Новые поля (`private`):

- `bool isTransformed` — в звериной форме или нет.

- `int angerLevel` — уровень ярости (чем выше, тем ближе к превращению).

Новые методы (`public`):

- `transform()` — превращение в волка (если `angerLevel` >= 50).

- `calmDown()` — снижает ярость и возвращает человеческий облик.

- `biteVampire()` — атака на вампира (может создавать гибридов).

### Конструкторы
**Конструкторы** при наследовании **не наследуются**.
При наследовании конструктор базового класса можно вызвать, используя **список инициализации**.
То есть не нужно в классе-наследнике прописывать инициализацию полей базового класса. В списке инициализации нужно указать только поля текущего класса и/или конструктор базового класса.

Покажу на более простом примере:

```cpp
class Point {
protected:
    int x, y;
public:
    Point(int x = 0, int y = 0): x(x), y(y) {}
};
class Point3D: public Point {
    int z;
public:
    Point3D(int x = 0, int y = 0, int z = 0): x(x), y(y), z(z) {} // вот так не надо
};
```

```cpp
class Point {
protected:
    int x, y;
public:
    Point(int x = 0, int y = 0): x(x), y(y) {}
};
class Point3D: public Point {
    int z;
public:
    Point3D(int x = 0, int y = 0, int z = 0): Point(x, y), z(z) {} // надо вот так
};
```
- Конструктор базового класса вызывается первым в списке

- Поля текущего класса инициализируются после

- Порядок инициализации совпадает с порядком объявления полей в классе

### Подключение конструктора базового класса
В примерах выше конструктор `Point3D` отличается от конструктора `Point` одним параметром - `z`. Все остальные параметры из `Point3D` передаются в `Point`. Однако, если бы у нас было бы полное соответствие по параметрам между двумя классами, то мы могли бы и не определять отдельный конструктор для `Point3D`, а подключить конструктор базового класса:

```cpp
class Point2D {                                   // Базовый класс
protected:
    int x, y;
public:
    Point2D() : x(0), y(0) {}                     // Конструктор по умолчанию
    Point2D(int x, int y) : x(x), y(y) {}         // Конструктор с параметрами

    void print() const {
        std::cout << "(" << x << ", " << y << ")";
    }
};
```

```cpp
class NamedPoint : public Point2D {                        // Наследник
public:
    // Наследует ВСЕ конструкторы Point2D
    using Point2D::Point2D;

    // Например, добавим метод для вывода с именем
    void print(const std::string& name) const {
        std::cout << name << ": ";
        Point2D::print();
    }
};
```
В классе `NamedPoint` подключаем конструкторы базового класса с помощью ключевого слова `using`:

`using Point2D::Point2D;`

Таким образом, класс `NamedPoint` фактически будет иметь те же конструкторы, что и `Point2D`.

### Запрет наследования
Бывают ситуации, когда наследование от класса может быть нежелательно. И с помощью спецификатора `final` мы можем запретить наследование:

`class Point final {};`
